(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isObject = require('isobject');

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;
  
  if (isObjectObject(o) === false) return false;
  
  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;
  
  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;
  
  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }
  
  // Most likely a plain Object
  return true;
};

},{"isobject":2}],2:[function(require,module,exports){
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function isObject(val) {
  return val != null && typeof val === 'object'
    && !Array.isArray(val);
};

},{}],3:[function(require,module,exports){
/**
* Create an event emitter with namespaces
* @name createNamespaceEmitter
* @example
* var emitter = require('./index')()
*
* emitter.on('*', function () {
*   console.log('all events emitted', this.event)
* })
*
* emitter.on('example', function () {
*   console.log('example event emitted')
* })
*/
module.exports = function createNamespaceEmitter () {
  var emitter = { _fns: {} }

  /**
  * Emit an event. Optionally namespace the event. Separate the namespace and event with a `:`
  * @name emit
  * @param {String} event – the name of the event, with optional namespace
  * @param {...*} data – data variables that will be passed as arguments to the event listener
  * @example
  * emitter.emit('example')
  * emitter.emit('demo:test')
  * emitter.emit('data', { example: true}, 'a string', 1)
  */
  emitter.emit = function emit (event) {
    var args = [].slice.call(arguments, 1)
    var namespaced = namespaces(event)
    if (this._fns[event]) emitAll(event, this._fns[event], args)
    if (namespaced) emitAll(event, namespaced, args)
  }

  /**
  * Create en event listener.
  * @name on
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.on('example', function () {})
  * emitter.on('demo', function () {})
  */
  emitter.on = function on (event, fn) {
    if (typeof fn !== 'function') { throw new Error('callback required') }
    (this._fns[event] = this._fns[event] || []).push(fn)
  }

  /**
  * Create en event listener that fires once.
  * @name once
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.once('example', function () {})
  * emitter.once('demo', function () {})
  */
  emitter.once = function once (event, fn) {
    function one () {
      fn.apply(this, arguments)
      emitter.off(event, one)
    }
    this.on(event, one)
  }

  /**
  * Stop listening to an event. Stop all listeners on an event by only passing the event name. Stop a single listener by passing that event handler as a callback.
  * You must be explicit about what will be unsubscribed: `emitter.off('demo')` will unsubscribe an `emitter.on('demo')` listener, 
  * `emitter.off('demo:example')` will unsubscribe an `emitter.on('demo:example')` listener
  * @name off
  * @param {String} event
  * @param {Function} [fn] – the specific handler
  * @example
  * emitter.off('example')
  * emitter.off('demo', function () {})
  */
  emitter.off = function off (event, fn) {
    var keep = []

    if (event && fn) {
      for (var i = 0; i < this._fns.length; i++) {
        if (this._fns[i] !== fn) {
          keep.push(this._fns[i])
        }
      }
    }

    keep.length ? this._fns[event] = keep : delete this._fns[event]
  }

  function namespaces (e) {
    var out = []
    var args = e.split(':')
    var fns = emitter._fns
    Object.keys(fns).forEach(function (key) {
      if (key === '*') out = out.concat(fns[key])
      if (args.length === 2 && args[0] === key) out = out.concat(fns[key])
    })
    return out
  }

  function emitAll (e, fns, args) {
    for (var i = 0; i < fns.length; i++) {
      if (!fns[i]) break
      fns[i].event = e
      fns[i].apply(fns[i], args)
    }
  }

  return emitter
}

},{}],4:[function(require,module,exports){
var createEmitter = require('namespace-emitter')
var isPlainObject = require('is-plain-object')
var extend = require('xtend')

/**
* Create the store
* @name createStoreEmitter
* @param {function} modifier
* @param {object} [initialState]
* @example
* var createStore = require('store-emitter')
* var store = createStore(function (action, state) {
*   if (action.type === 'change_something') {
*     return { something: 'changed' }
*   }
* })
*/
module.exports = function createStore (modifier, initialState) {
  if (typeof modifier !== 'function') {
    throw new Error('first argument must be a function')
  }

  var emitter = createEmitter()
  initialState = initialState || {}
  var isEmitting = false
  var state = extend(initialState)
  store.initialState = getInitialState
  store.getState = getState
  store.emit = store
  store.on = on
  store.once = once
  store.off = off
  return store

  /**
  * Send an action to the store. Takes a single object parameter. Object must include a `type` property with a string value, and can contain any other properties.
  * @name store
  * @param {object} action
  * @param {string} action.type
  * @example
  * store({
  *   type: 'example'
  *   exampleValue: 'anything'
  * })
  */
  function store (action) {
    if (!action || !isPlainObject(action)) {
      throw new Error('action parameter is required and must be a plain object')
    }

    if (!action.type || typeof action.type !== 'string') {
      throw new Error('type property of action is required and must be a string')
    }

    if (isEmitting) {
      throw new Error('modifiers may not emit actions')
    }

    isEmitting = true
    var oldState = extend(state)
    state = modifier(action, oldState)
    var newState = extend(state)

    emitter.emit(action.type, action, newState, oldState)
    isEmitting = false
  }

  /**
  * Get the initial state of the store
  * @name store.initialState
  * @example
  * var state = store.initialState()
  */
  function getInitialState () {
    return initialState
  }

  /**
   * Get the current state of the store
   * @name store.getState
   * @example
   * var state = store.getState()
   */
  function getState () {
    return state
  }

  /**
  * Listen for changes to the store
  * @name store.on
  * @param {string} event – an action type
  * @param {Function} callback
  * @example
  * store.on('*', function (action, state, oldState) {
  *
  * })
  *
  * store.on('article', function (action, state, oldState) {
  *
  * })
  *
  * store.on('article:delete', function (action, state, oldState) {
  *
  * })
  */
  function on (event, callback) {
    emitter.on(event, callback)
  }

  /**
  * Listen for a single change to the store
  * @name store.once
  * @param {string} event – an action type
  * @param {Function} callback
  * @example
  * store.once('article', function (action, state, oldState) {
  *
  * })
  */
  function once (event, callback) {
    emitter.once(event, callback)
  }

  /**
  * Stop listening for changes to the store. Passing just the action type will remove all listeners for that action type.
  * @name store.off
  * @param {string} event – an action type
  * @param {Function} [callback] – optional callback
  * @example
  * store.off('article', function (action, state, oldState) {
  *
  * })
  */
  function off (event, callback) {
    emitter.off(event, callback)
  }
}

},{"is-plain-object":1,"namespace-emitter":3,"xtend":5}],5:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],6:[function(require,module,exports){
/* Nos permite mantener el estado completo de la aplicacion en un unico objeto que emite eventos ante cualquier modificacion */
var createStore = require('store-emitter')

/* Permite parchear el estado con datos nuevos de manera mas simple. */
var xtend = require('xtend')

/* Exportamos el modulo para que pueda ser importado con webworkify. Esto nos permite manejar todo en un unico bundle de browserify sin necesidad de compilar el worker aparte. */
module.exports = function (self) {
/* Qué vamos a hacer con los eventos que reciba el store.
 * Por el momento, solo respondemos a eventos de modificacion de url. */
function modifier ( action, state ) {
  if (action.type === 'setUrl')
  return xtend(state, {url : action.payload})
}

/* Creamos el store pasando como parámetros la función que lo modifica y el estado inicial. */
var store = createStore(modifier, 
{
  url: '/',
  title: "El titulo",
  tabs: [
  {title: "Primer titulo", content: "Primer contenido", activeTab: true},
  {title: "Segundo titulo", content: "Segundo contenido"},
  {title: "tercer titulo", content: "Segundo contenido"},
  {title: "cuarto titulo", content: "Segundo contenido"},
  {title: "cuarto titulo", content: "Segundo contenido"},
  {title: "cuarto titulo", content: "Segundo contenido"}
  ]
}
)
/* Ante cualquier tipo de modificacion en el estado, enviamos el nuevo estado al UI thread para que actualice las vistas. */
store.on('*', function ( action, state, old ) { 
  self.postMessage(state)
})

/* Ante cualquier evento proveniente del UI thread actualizamos el estado con los nuevos datos. */
self.addEventListener('message', function(ev){store(ev.data)})

/* Inicializamos el UI thread enviandole el estado inicial. */
 // self.postMessage(store.getState())
}

},{"store-emitter":4,"xtend":5}]},{},[6]);
